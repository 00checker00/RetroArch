##### Config file for SSNES

## If enabled, load libsnes from a dynamic location.
# libsnes_path = "/path/to/libsnes.so"

#### Video

# Windowed xscale and yscale (Real x res: 296 * xscale, real y scale: 224 * xscale)
# video_xscale = 3.0
# video_yscale = 3.0

# Fullscreen resolution
# video_fullscreen_x = 1920
# video_fullscreen_y = 1200

# Start in fullscreen. Can be changed at runtime.
# video_fullscreen = false

# Video vsync.
# video_vsync = true

# Smoothens picture with bilinear filtering. Should be disabled if using Cg shaders.
# video_smooth = true

# Forces rendering area to stay equal to SNES aspect ratio 4:3 or as defined in video_aspect_ratio.
# video_force_aspect = true

# A floating point value for video aspect ratio (width / height)
# video_aspect_ratio = 1.333

# Path to Cg shader. If enabled
# video_cg_shader = "/path/to/cg/shader.cg"

# Path to bSNES-style XML shader. If both Cg shader path and XML shader path are defined, Cg shader will take priority.
# video_bsnes_shader = "/path/to/bsnes/xml/shader.shader"

# CPU-based filter. Valid ones are: hq2x, hq4x, grayscale, bleed, ntsc.
# video_filter = ntsc

# Path to a TTF font used for rendering messages. This path must be defined to enable fonts.
# video_font_path = 

# Size of the TTF font rendered.
# video_font_size = 48

# Offset for where messages will be placed on screen. Values are in range 0.0 to 1.0 for both x and y values.
# video_message_pos_x = 0.05
# video_message_pox_y = 0.05

#### Audio

# Enable audio.
# audio_enable = true

# Audio output samplerate.
# audio_out_rate = 48000

# Audio input samplerate from libsnes.
# Lower this (slightly) if you are experiencing frequent audio dropouts while vsync is enabled.
# Conversely, increase this slightly if you are experiencing good audio, 
# but lots of dropped frames. Reasonable values for this is 32000 +/- 100 Hz.
# audio_in_rate = 31980

# Audio driver backend. Depending on configuration possible candidates are: alsa, oss, jack, rsound, roar, openal, sdl and xaudio
# audio_driver =

# Override the default audio device the audio_driver uses.
# audio_device =

# Will sync (block) on audio. Recommended.
# audio_sync = true

# Desired audio latency in milliseconds. Might not be honored if driver can't provide given latency.
# audio_latency = 64

# libsamplerate quality. Valid values are from 1 to 5. These values map to zero_order_hold, linear, sinc_fastest, sinc_medium and sinc_best.
# audio_src_quality =

### Input

# Input driver. Depending on video driver, it might force a different input driver.
# input_driver = sdl

# Defines axis threshold. Possible values are [0.0, 1.0]
# input_axis_threshold = 0.5

# Keyboard input. Will recognize normal keypresses and special keys like "left", "right", and so on.
# input_player1_a = x
# input_player1_b = z
# input_player1_y = a
# input_player1_x = s
# input_player1_start = enter
# input_player1_select = rshift
# input_player1_l = q
# input_player1_r = w
# input_player1_left = left
# input_player1_right = right
# input_player1_up = up
# input_player1_down = down

# If desired, it is possible to override which joypads are being used for player 1 and 2. First joypad available is 0.
# input_player1_joypad_index = 0
# input_player2_joypad_index = 1

# Joypad buttons. Figure these out by looking at jstest /dev/input/js0 output.
# You can use joypad hats with hnxx, where n is the hat, and xx is a string representing direction. 
# E.g. "h0up"
# input_player1_a_btn = 1
# input_player1_b_btn = 0
# input_player1_y_btn = 2
# input_player1_x_btn = 3
# input_player1_start_btn = 7
# input_player1_select_btn = 6
# input_player1_l_btn = 4
# input_player1_r_btn = 5
# input_player1_left_btn = 11
# input_player1_right_btn = 12
# input_player1_up_btn = 13
# input_player1_down_btn = 14

# Axis for DPAD. 
# Needs to be either '+' or '-' in the first character signaling either positive or negative direction of the axis, then the axis number. 
# Do note that every other input option has the corresponding _btn and _axis binds as well; they are omitted here for clarity.
# input_player1_left_axis = -0
# input_player1_right_axis = +0
# input_player1_up_axis = +1
# input_player1_down_axis = -1

# Same stuff, just for player two.
# input_player2_a = 
# input_player2_b =
# input_player2_y =
# input_player2_x =
# input_player2_start =
# input_player2_select =
# input_player2_l =
# input_player2_r =
# input_player2_left =
# input_player2_right =
# input_player2_up =
# input_player2_down =

# input_player2_a_btn = 1
# input_player2_b_btn = 0
# input_player2_y_btn = 2
# input_player2_x_btn = 3
# input_player2_start_btn = 7
# input_player2_select_btn = 6
# input_player2_l_btn = 4
# input_player2_r_btn = 5
# input_player2_left_btn = 11
# input_player2_right_btn = 12
# input_player2_up_btn = 13
# input_player2_down_btn = 14


# input_player2_left_axis = -0
# input_player2_right_axis = +0
# input_player2_up_axis = -1
# input_player2_down_axis = +1

# Toggles fullscreen.
# input_toggle_fullscreen = f
# Saves state.
# input_save_state = f2
# Loads state.
# input_load_state = f4

# State slots. With slot set to 0, save state name is *.state (or whatever defined on commandline).
# When slot is != 0, path will be $path%d, where %d is slot number.
# input_state_slot_increase = f7
# input_state_slot_decrease = f6

# Toggles between fast-forwarding and normal speed.
# input_toggle_fast_forward = space

# Key to exit emulator cleanly. 
# Killing it in any hard way (SIGTERM, SIGKILL, etc, will terminate emulator without saving RAM, etc.)
# input_exit_emulator = escape
