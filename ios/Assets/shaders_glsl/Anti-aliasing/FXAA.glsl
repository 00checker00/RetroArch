// GLSL shader autogenerated by cg2glsl.py.
#if defined(VERTEX)
varying     vec4 _color;
varying     vec2 _texCoord1;
varying     vec4 _vpos1;
varying     vec4 _position1;
varying     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
struct VERTEX_OUTPUT {
    vec4 _position1;
    vec4 _vpos1;
    vec2 _texCoord1;
};
struct output_dummy {
    vec4 _color;
};
VERTEX_OUTPUT _ret_0;
uniform mat4 MVPMatrix;
vec4 _r0003;
attribute vec4 VertexCoord;
attribute vec4 TexCoord;
varying vec4 TEX1;
varying vec4 TEX0;
 

         mat4 transpose_(mat4 matrix)
         {
            mat4 ret;
            for (int i = 0; i < 4; i++)
               for (int j = 0; j < 4; j++)
                  ret[i][j] = matrix[j][i];

            return ret;
         }
         
uniform int FrameDirection;
uniform int FrameCount;
#ifdef GL_ES
uniform mediump vec2 OutputSize;
uniform mediump vec2 TextureSize;
uniform mediump vec2 InputSize;
#else
uniform vec2 OutputSize;
uniform vec2 TextureSize;
uniform vec2 InputSize;
#endif
void main()
{
    mat4 MVPMatrix_ = transpose_(MVPMatrix);
    _r0003.x = dot(MVPMatrix_[0], VertexCoord);
    _r0003.y = dot(MVPMatrix_[1], VertexCoord);
    _r0003.z = dot(MVPMatrix_[2], VertexCoord);
    _r0003.w = dot(MVPMatrix_[3], VertexCoord);
    _ret_0._position1 = _r0003;
    _ret_0._vpos1 = _r0003;
    _ret_0._texCoord1 = TexCoord.xy;
    gl_Position = _r0003;
    TEX1 = _r0003;
    TEX0.xy = TexCoord.xy;
    return;
    TEX1 = _ret_0._vpos1;
    TEX0.xy = _ret_0._texCoord1;
} 
#elif defined(FRAGMENT)
#ifdef GL_ES
precision mediump float;
#endif
varying     vec4 _color;
varying     vec2 _texCoord;
varying     vec4 _vpos;
varying     float _frame_rotation;
struct input_dummy {
    vec2 _video_size;
    vec2 _texture_size;
    vec2 _output_dummy_size;
    float _frame_count;
    float _frame_direction;
    float _frame_rotation;
};
struct VERTEX_OUTPUT {
    vec4 _vpos;
    vec2 _texCoord;
};
struct output_dummy {
    vec4 _color;
};
vec4 _TMP19;
vec4 _TMP18;
vec4 _TMP17;
vec4 _TMP16;
vec2 _TMP15;
vec2 _TMP14;
float _TMP13;
float _TMP12;
float _TMP11;
float _TMP10;
float _TMP9;
float _TMP8;
float _TMP7;
float _TMP6;
float _TMP5;
vec4 _TMP4;
vec4 _TMP3;
vec4 _TMP2;
vec4 _TMP1;
vec4 _TMP0;
uniform sampler2D Texture;
input_dummy _IN1;
vec2 _c0026;
vec2 _c0028;
vec2 _c0030;
vec2 _c0032;
float _a0062;
vec2 _b0070;
vec2 _c0074;
vec2 _c0076;
vec2 _c0078;
vec2 _c0080;
varying vec4 TEX0;
 
uniform int FrameDirection;
uniform int FrameCount;
#ifdef GL_ES
uniform mediump vec2 OutputSize;
uniform mediump vec2 TextureSize;
uniform mediump vec2 InputSize;
#else
uniform vec2 OutputSize;
uniform vec2 TextureSize;
uniform vec2 InputSize;
#endif
void main()
{
    output_dummy _OUT;
    vec2 _inverse_resolution;
    float _lumaNW;
    float _lumaNE;
    float _lumaSW;
    float _lumaSE;
    float _lumaM;
    float _lumaMin;
    float _lumaMax;
    vec2 _dir;
    float _dirReduce;
    float _rcpDirMin;
    vec3 _rgbA;
    vec3 _rgbB;
    float _lumaB;
    _inverse_resolution = 1.00000000E+00/InputSize.xy;
    _c0026 = (TEX0.xy + vec2( -1.00000000E+00, -1.00000000E+00))*_inverse_resolution;
    _TMP0 = texture2D(Texture, _c0026);
    _c0028 = (TEX0.xy + vec2( 1.00000000E+00, -1.00000000E+00))*_inverse_resolution;
    _TMP1 = texture2D(Texture, _c0028);
    _c0030 = (TEX0.xy + vec2( -1.00000000E+00, 1.00000000E+00))*_inverse_resolution;
    _TMP2 = texture2D(Texture, _c0030);
    _c0032 = (TEX0.xy + vec2( 1.00000000E+00, 1.00000000E+00))*_inverse_resolution;
    _TMP3 = texture2D(Texture, _c0032);
    _TMP4 = texture2D(Texture, TEX0.xy);
    _lumaNW = dot(_TMP0.xyz, vec3( 2.98999995E-01, 5.87000012E-01, 1.14000000E-01));
    _lumaNE = dot(_TMP1.xyz, vec3( 2.98999995E-01, 5.87000012E-01, 1.14000000E-01));
    _lumaSW = dot(_TMP2.xyz, vec3( 2.98999995E-01, 5.87000012E-01, 1.14000000E-01));
    _lumaSE = dot(_TMP3.xyz, vec3( 2.98999995E-01, 5.87000012E-01, 1.14000000E-01));
    _lumaM = dot(_TMP4.xyz, vec3( 2.98999995E-01, 5.87000012E-01, 1.14000000E-01));
    _TMP5 = min(_lumaNW, _lumaNE);
    _TMP6 = min(_lumaSW, _lumaSE);
    _TMP7 = min(_TMP5, _TMP6);
    _lumaMin = min(_lumaM, _TMP7);
    _TMP8 = max(_lumaNW, _lumaNE);
    _TMP9 = max(_lumaSW, _lumaSE);
    _TMP10 = max(_TMP8, _TMP9);
    _lumaMax = max(_lumaM, _TMP10);
    _dir.x = -((_lumaNW + _lumaNE) - (_lumaSW + _lumaSE));
    _dir.y = (_lumaNW + _lumaSW) - (_lumaNE + _lumaSE);
    _a0062 = (_lumaNW + _lumaNE + _lumaSW + _lumaSE)*3.12500000E-02;
    _dirReduce = max(_a0062, 3.90625000E-03);
    _TMP11 = abs(_dir.x);
    _TMP12 = abs(_dir.y);
    _TMP13 = min(_TMP11, _TMP12);
    _rcpDirMin = 1.00000000E+00/(_TMP13 + _dirReduce);
    _b0070 = _dir*_rcpDirMin;
    _TMP14 = max(vec2( -8.00000000E+00, -8.00000000E+00), _b0070);
    _TMP15 = min(vec2( 8.00000000E+00, 8.00000000E+00), _TMP14);
    _dir = _TMP15*_inverse_resolution;
    _c0074 = TEX0.xy + _dir*-1.66666657E-01;
    _TMP16 = texture2D(Texture, _c0074);
    _c0076 = TEX0.xy + _dir*1.66666687E-01;
    _TMP17 = texture2D(Texture, _c0076);
    _rgbA = 5.00000000E-01*(_TMP16.xyz + _TMP17.xyz);
    _c0078 = TEX0.xy*_inverse_resolution + _dir*-5.00000000E-01;
    _TMP18 = texture2D(Texture, _c0078);
    _c0080 = TEX0.xy + _dir*5.00000000E-01;
    _TMP19 = texture2D(Texture, _c0080);
    _rgbB = _rgbA*5.00000000E-01 + 2.50000000E-01*(_TMP18.xyz + _TMP19.xyz);
    _lumaB = dot(_rgbB, vec3( 2.98999995E-01, 5.87000012E-01, 1.14000000E-01));
    if (_lumaB < _lumaMin || _lumaB > _lumaMax) { 
        _OUT._color = vec4(_rgbA.x, _rgbA.y, _rgbA.z, 1.00000000E+00);
    } else {
        _OUT._color = vec4(_rgbB.x, _rgbB.y, _rgbB.z, 1.00000000E+00);
    } 
    gl_FragColor = _OUT._color;
    return;
} 
#endif
